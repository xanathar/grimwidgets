-- This file has been generated by Dungeon Editor 1.3.6

--- level 1 ---

mapName("Unnamed")
setWallSet("dungeon")
playStream("assets/samples/music/dungeon_ambient.ogg")
mapDesc([[
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
##############...###############
##############...###############
##############...###############
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
]])
spawn("starting_location", 15,15,0, "starting_location")
spawn("torch_holder", 15,14,0, "torch_holder_1")
	:addTorch()
spawn("script_entity", 17,13,0, "gw")
	:setSource("keyHooks = {}\
elements = {\
\9gui = {},\
\9stats = {},\
\9skills = {},\
\9inventory = {}\
}\
\
\
function addElement(element,hookName)\
\9hookName = hookName or 'gui'\
   \9table.insert(elements[hookName],element)\
end\
\
function removeElement(id,hookName)\
\9hookName = hookName or 'gui'\
\9for i,elem in ipairs(elements[hookName]) do\
\9\9if elem.id == id then\
\9\9\9table.remove(elements[hookName],i)\
\9\9\9return\
\9\9end\
\9end\
end\
\
function drawElements(g,hookName,champion)\
\9hookName = hookName or 'gui'\
\9for id,element in pairs(elements[hookName]) do\
\9\9element:draw(g,champion)\
\9end\
end\
\
function draw(g)\
\9processKeyHooks(g)\
\9drawElements(g,'gui')\
\9gw_events.processEvents(g)\
end\
\
\
function drawInventory(g,champ)\
\9drawElements(g,'inventory',champ)\
end\
\
function drawStats(g,champ)\
\9drawElements(g,'stats',champ)\
end\
\
function drawSkills(g,champ)\
\9drawElements(g,'skills',champ)\
end\
\
function setKeyHook(key,ptoggle,pcallback)\
\9keyHooks[key] = {callback=pcallback,toggle=ptoggle,active=false}\
end\
\
function processKeyHooks(g)\
\9for key,hookDef in pairs(keyHooks) do\
\9\9if hookDef.toggle then\
\9\9\9-- toggle key state and add small threshold so the state doesn't change immediately\
\9\9\9if not keyToggleThresholdTimer and g.keyDown(key) then\
\9\9\9\9hookDef.active = not hookDef.active\
\9\9\9\9local t = spawn('timer',party.level,0,0,1,'keyToggleThresholdTimer')\
\9\9\9\9t:setTimerInterval(0.3)\
\9\9\9\9t:addConnector('activate','gw','destroyKeyToggleThresholdTimer')\
\9\9\9\9t:activate()\
\9\9\9end\
\9\9\9if hookDef.active then\
\9\9\9\9hookDef.callback(g)\
\9\9\9end\9\
\9\9elseif g.keyDown(key) then\
\9\9\9hookDef.callback(g)\
\9\9end\
\9end\
end\
\
function destroyKeyToggleThresholdTimer()\
\9keyToggleThresholdTimer:destroy()\
end\
\
\
\
\
")
spawn("script_entity", 31,31,3, "debug")
	:setSource("\
-- draws size*size grid and shows mouse coordinates in upper left corner\
-- you can enable it by calling debug.grid(100), disable: debug.grid() \
-- currently works only in fullscreen mode because of g.width g.height bug\
\
function grid(size)\
\9if not size then\
\9\9gw.removeElement('grid')\
\9\9return\
\9end\
\9size = size or 100\
\9local grid = {}\
\9grid.id = 'grid'\
\9grid.size = size\
\9grid.draw = function(self,g)\
\9\9local h = math.ceil(g.height/self.size)\
\9\9local w = math.ceil(g.width/self.size)\
\9\9for x = 0,w do\
\9\9\9g.drawRect(x*self.size,0,1,g.height)\
\9\9end\
\9\9for y = 0,h do\
\9\9\9g.drawRect(0,y*self.size,g.width,1)\
\9\9end\9\9\
\9\9g.drawText('x: '..g.mouseX..', y:'..g.mouseY,20,20)\
\9\9g.drawText('g.width - '..g.width - g.mouseX..', g.height - '..g.height - g.mouseY,20,40)\
\9end\
\9gw.addElement(grid)\
end\
\
function debugGrid()\
\9grid(100)\
end")
spawn("wall_button", 14,15,3, "wall_button_1")
	:addConnector("toggle", "debug", "debugGrid")
spawn("dungeon_wall_text", 14,15,3, "dungeon_wall_text_1")
	:setWallText("Enable mouse grid")
spawn("gw_event", 16,16,2, "gw_event_1")
	:setSource("-- is this event enabled?\
enabled = true\
\
-- name of the imeage to show\
image = \"mod_assets/images/example-image.dds\"\
\
-- todo: the following x,y coords are temporary.\
--       They should be calculated automatically.\
\
-- image position\
image_x = 40\
image_y = 60\
\
-- text description position\
text_x = 220\
text_y = 60\
\
-- buttons position\
buttons_x = 220\
buttons_y = 160\
buttons_width = 200\
\
-- initial state\
state = 1\
\
-- functions called after specific buttons being pressed\
function onHeal()\
    hudPrint(\"Healing!\")\
    state = 2\
end\
\
function onTalk()\
    hudPrint(\"Dwarf is in too much pain to talk.\")\
end\
\
function onLeave()\
    enabled = false\
end\
\
function onHealed()\
    hudPrint(\"He is healed already!\")\
end\
\
-- defines states. Each entry must have exactly two columns:\
-- first is state number, the second is description shown.\
states = {\
  { 1, \"An injured dwarf lies on the ground before you,\\n\" ..\
       \"nearly unconscious from his wounds.\" },\
  { 2, \"The healed dwarf is happy.\" }\
}\
\
-- defines possible actions in each state. Each entry has\
-- 3 values. First is state number. Second is action name\
-- (will be printed on a button). The third is a function\
-- that will be called when action is taken (i.e. button\
-- is pressed).\
actions = {\
  { 1, \"tend his wounds\", onHeal },\
  { 1, \"talk\", onTalk },\
  { 1, \"leave\", onLeave},\
  { 2, \"healed\", onHealed}\
}\
")
spawn("script_entity", 19,13,1, "gw_events")
	:setSource("-- processes events that are located in the same\
-- location as party\
function processEvents(ctx)\
\
\9local items=\"\"\
    for i in entitiesAt(party.level, party.x, party.y) do\
\9\9if i.class == \"ScriptEntity\" then\
\9\9\9processEncounter(ctx, i)\
\9\9end\
    end\
end\
\
function processEncounter(ctx, eventScript)\
\9if not sanityCheck(eventScript) then\
\9\9return\
\9end\
\
\9local state = eventScript.state\
\9if state == nil then\
\9\9state = 1\
\9end\
\
\9-- Check if image is defined for this event\
\9local image_x = eventScript.x\
\9local image_y = eventScript.y\
\9if not image_x then\
\9    image_x = 20\
\9end\
\9if not image_y then\
\9\9image_y = 20\
\9end\
\9if eventScript.image then\
\9   ctx.drawImage(eventScript.image, image_x, image_y)\
\9end\
\9\
\9\
\9-- Ok, now write a text\
\9local text_x = eventScript.text_x\
\9local text_y = eventScript.text_y\
\9if not text_x then\
\9\9text_x = 200\
\9end\
\9if not text_y then\
\9\9text_y = 50\
\9end\
\9\
\9stateData = eventScript.states[state]\
\9ctx.color(255, 255, 255)\
\9ctx.drawText(stateData[2], text_x, text_y)\
\9\9\
\9local tbl = eventScript.actions\
\9\9\
\9local buttons_x = eventScript.buttons_x\
\9local buttons_y = eventScript.buttons_y\
\9local buttons_width = eventScript.buttons_width\
\9\9\
\9printChoices(ctx, state, tbl, buttons_x, buttons_y, buttons_width)\
end\
\
function printChoices(ctx, current_state, states, x, y, width)\
\9for key1,value in pairs(states) do\
\9\9if value[1] == current_state then\
\9\9\9showButton(ctx, x, y, width, value[2], value[3])\
\9\9\9y = y + 30\
\9\9end\
\9end\
\
end\
\
function sanityCheck(e)\
\9if e.name ~= \"gw_event\" then\
\9\9return false\
\9end\
    if e.states == nil then\
\9\9return false\
\9end\
\9\
\9if e.actions == nill then\
\9\9return false\
\9end\
\9\
\9if (e.enabled ~= true) then\
\9\9return false\
\9end\
\9\
\9return true\
\
end\
\
function showButton(ctx, x, y, width, text, callback)\
    -- draw button1 with text\
    ctx.color(128, 128, 128)\
    ctx.drawRect(x, y, width, 20)\
    ctx.color(255, 255, 255)\
    ctx.drawText(text, x + 10, y + 15)\
\9local name=\"button\"..x..y\
\9local height = 30\
    if ctx.button(\"button1\", x, y, width, height) then\
\9\9callback(ctx)\
\9end\
end")
spawn("script_entity", 29,31,2, "spell_book")
	:setSource("-- For testing/developement purposes\
-- I hope that this case is complex enough to show the possible flaws on grimwigets.\
\
spells = {}\
offset = {\
\9x=20,\
\9y=20,\
\9line_h = 20,\
}\
runeMap = {\
\9A='rune1_fire',\
\9B='rune2_death',\
\9C='rune3_air',\
\9D='rune4_spirituality',\
\9E='rune5_balance',\
\9F='rune6_physicality',\
\9G='rune7_earth',\
\9H='rune8_life',\
\9I='rune9_water'\
}\
function activate()\
\
\
end\
\
function setSpells(pspells)\
\9spells = {}\
\9i = 1\
\9for spellName,def in pairs(pspells) do\
\9\9table.insert(spells,i,def)\
\9\9i = i + 1\
\9end\
end\
\
function drawSpellBook(self,g,champion)\
\9if champion and champion:getClass() ~= 'Mage' then\
\9\9gw.removeElement('spell_book_runes','skills')\
\9\9return\
\9end\
\9local x = spell_book.offset.x\
\9local y = spell_book.offset.y\
\9\
\9g.color(255,255,255,200)\
\9g.drawImage(\"mod_assets/textures/book_900.tga\",x,y)\
\9\
\9g.font('medium')\
\9local row = 1\
\9for name,spell in pairs(spells) do\
\9\9if g.button(spell.name..'_b',x,y + row * 20,300,20) then\
\9\9\9if (spell.runes) then\
\9\9\9\9local rune_images = {}\
\9\9\9\9\
\9\9\9\9for i=1,#spell.runes do\
\9\9\9\9\9local runeChar = string.sub(spell.runes,i,i)\
\9\9\9\9\9rune_images[i] = 'mod_assets/textures/'..runeMap[runeChar]..'.tga'\
\9\9\9\9end\
\9\9\9\9\
\9\9\9\9local runes = {\
\9\9\9\9\9id='spell_book_runes',\
\9\9\9\9\9images = rune_images,\
\9\9\9\9\9description = spell.description \
\9\9\9\9}\
\9\9\9\9runes.draw = function(self,g,champ)\
\9\9\9\9\9g.font('small')\
\9\9\9\9\9for i,imagePath in ipairs(self.images) do\
\9\9\9\9\9\9g.drawImage(imagePath,500+100*i,200)\
\9\9\9\9\9end\
\9\9\9\9\9g.drawText(self.description,500,300)\
\9\9\9\9end\
\9\9\9\9gw.removeElement('spell_book_runes','skills')\
\9\9\9\9gw.addElement(runes,'skills')\
\9\9\9\9\
\9\9\9end\
\9\9\9\
\9\9end\9\9\
\9\9\
\9\9g.color(237,175,135,255)\
\9\9g.drawRect(x + 30 ,y+row*20,19,19)\
\9\9\
\
\9\9g.color(250,250,250,255)\
\9\9g.drawText(spell.uiname,x + 50, y + 20 + row*20)\
\9\9row = row + 1\
\9end\
end\
\
-- testing\
setSpells{\
\9{name='fireburst',uiname='Fireburst',runes='A',description='Caster creates a quick burst of fire in front of him'},\
\9{name='ice_shards',uiname='Ice Shards',runes='GI',description='Caster shoots a flurry of ice shards in front of him'}\
}\
\
\9\
local e = {}\
e.id = 'spell_book_mage'\
e.draw = spell_book.drawSpellBook\
--gw.setKeyHook('m',true,e.draw)\
gw.addElement(e,'skills')\
\
")
spawn("script_entity", 21,13,2, "compass")
	:setSource("-- This example draws a compass as a GUI element. Depending on which\
-- activation mode is chosen, it can be visible all time, toggled\
-- with 'c' key or shown only when 'c' is pressed.\
\
-- draws actual compass\
-- this function is called when compass is visible all time\
function drawCompass(self, g)\
\9local x = 10\
\9local y = g.height - 200\
\9\
\9local dir = string.sub(\"NESW\", party.facing + 1, party.facing + 1)\
\9g.drawImage(\"mod_assets/textures/compass_full_\"..dir..\".tga\", x, y)\
end\
\
-- this is a simple wrapper function that is called as key press\
-- hook. It calls drawCompass function.\
function callback(g)\
\9drawCompass(self, g)\
end\
\
local e = {}\
e.id = 'compass'\
e.draw = drawCompass\
e.callback = callback\
\
-- uncomment this to enabled/disable compass by pressing C\
gw.setKeyHook('c', true, e.callback)\
\
-- Uncomment this to show compass by pressing C\
-- gw.setKeyHook('c', false, e.callback)\
\
-- Uncomment this to have compass permanently visible\
-- gw.addElement(e,'gui')")
